# Rails API

On an existing Rails application, it's possible to add an API by simply adding controllers that render JSON instead of HTML

It's also possible to user Rails as a pure API (that is, no HTML rendering) with the `rails-api` gem:

```sh
$ gem install rails-api
$ rails-api new my-api-app
```

This will create an API optimized Rails Application.

:pencil: **Note** `rails-api` has been merged in Rails 5 (which is currently in release candidate).

## Rendering JSON

Rendering a single object or a collection of objects is pretty straightforward:

```ruby
# app/controllers/posts_controller.rb
def index
  @posts = Post.all

  render json: @posts
end
```

Rails will serialize `@posts` in JSON format and render it:

```json
[
    {
        "id": 1,
        "title": "Hello World",
        "content": "First post",
        "created_at": "2016-06-15T14:01:34.262Z",
        "updated_at": "2016-06-15T14:01:34.262Z",
        "author_name": "me"
    },
    {
        "id": 3,
        "title": "Second post",
        "content": "Some interesting stuff",
        "created_at": "2016-06-15T14:05:53.532Z",
        "updated_at": "2016-06-15T14:05:53.532Z",
        "author_name": "me again"
    }
]
```

## Serializing JSON

But we are pretty limited:

- What if we don't want to render all the attributes of an object (like user's admin status for example)?
- What if we want to render the post's comments when rendering a post?

There are several gems we can use to customize the serialization of our objects. We are going to use [ActiveModel::Serializers](https://github.com/rails-api/active_model_serializers) (AMS).

Let's add it to our blog application's Gemfile:

```ruby
# Gemfile
gem 'active_model_serializers', '~> 0.10.0'
```

And then run:

```sh
$ bundle install
```

:pencil: **Note** whenever we add a new gem to our application's `Gemfile`, it's always clever to read the gem's documentation. Even if we know the gem, we might have forgotten some things and it might have evolved since the last time we used it.

Generate a serializer for an existing model:

```sh
$ rails generate serializer post
```

This will generate a new serializer:

```ruby
# app/serializers/post_serializer.rb
class PostSerializer < ActiveModel::Serializer
  attributes :id
end
```

We need to whitelist the attributes that will be serialized. AMS also supports `has_many`, `belongs_to` and `has_one`:

```ruby
# app/serializers/post_serializer.rb
class PostSerializer < ActiveModel::Serializer
  attributes :id, :title, :content, :author_name

  has_many :comments
end
```

Have a look at [http://localhost:3000/posts](http://localhost:3000/posts):

- The post's comments are also rendered
- The posts don't include `created_at` and `:updated_at` anymore

By default, AMS looks for a serializer with the same name as the object (or collection of objects) rendered and uses it.

We can also add custom attributes:

```ruby
# app/serializers/post_serializer.rb
class PostSerializer < ActiveModel::Serializer
  attributes :id, :title, :content, :author_name, :time_of_creation

  has_many :comments

  def time_of_creation
    object.created_at.strftime("%e %B %Y at %Hh%M")
  end
end
```

It's also possible to pass some custom options to a serializer:

```ruby
# app/controllers/posts_controller.rb
def show
  render json: PostSerializer.new(@post, stars: 4)
end
```

```ruby
# app/serializers/post_serializer.rb
class PostSerializer < ActiveModel::Serializer
  attributes :id, :title, :content, :author_name, :time_of_creation, :review

  has_many :comments

  def time_of_creation
    object.created_at.strftime("%e %B %Y at %Hh%M")
  end

  def review
    "#{instance_options[:stars]} stars"
  end
end
```
